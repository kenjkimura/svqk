package dev.aulait.svqk.arch.openapi;

import io.quarkus.runtime.annotations.RegisterForReflection;
import io.quarkus.smallrye.openapi.OpenApiFilter;
import java.util.*;
import java.util.regex.Pattern;
import org.eclipse.microprofile.openapi.OASFilter;
import org.eclipse.microprofile.openapi.models.OpenAPI;
import org.eclipse.microprofile.openapi.models.PathItem;
import org.eclipse.microprofile.openapi.models.parameters.Parameter;

@OpenApiFilter
@RegisterForReflection
public class SvqkOASFilter implements OASFilter {
  private static final Pattern PATH_VAR = Pattern.compile("\\{([^}/]+)\\}");

  @Override
  public void filterOpenAPI(OpenAPI openAPI) {
    if (openAPI == null || openAPI.getPaths() == null) return;

    openAPI.getPaths().getPathItems().entrySet().stream().forEach(this::reorderPathParameters);
  }

  /**
   * Reorders path parameters in the OpenAPI instance to match the placeholder order in the API
   * path. The other parameters such as query parameters retain their original order and are placed
   * after the path parameters.
   *
   * <p>The OpenAPI documents generated by svqk-generator list path parameters in alphabetical order
   * of their names (a). From these OpenAPI documents, svqk-generator generates API clients (b).
   * However, at the call sites where the generated API clients are used for single-record
   * GET/UPDATE/DELETE operations, path parameters are expected in the primary-key order of the
   * target table, which corresponds to the placeholder order in the API path (c).
   *
   * <p>(a) svqk-generator uses Quarkus to generate OpenAPI documents. See
   * svqk-generator/.yo-rc.json (genOpenApiJsonCmd).
   *
   * <p>(b) svqk-generator uses swagger-typescript-api to generate API clients. See
   * svqk-generator/src/main/lib/ApiClientGenerator.ts.
   *
   * <p>(c) This generation logic is implemented in the following templates and shared functions:
   * generators/app/templates/arch/frontend/routes/entityId/+page.ts
   * generators/app/templates/lib/typescript-common.ejs (buildDetailApiCall)
   *
   * <p><b>Problematic Example</b>
   *
   * <p>In the generated client, the parameters of the get function are listed in alphabetical
   * order, while the caller passes arguments in the primary-key order that matches the path
   * definition.
   *
   * <p><b>Function Definition (generated, alphabetical order)</b>
   *
   * <pre>{@code
   * get: (
   *   accountId: string,
   *   userId: string,
   *   params: RequestParams = {}
   * ) =>
   *   this.request<UserModel, any>({
   *     path: `/api/user/${userId}/${accountId}`,
   *     method: "GET",
   *     format: "json",
   *     ...params,
   *   }),
   * }</pre>
   *
   * <p><b>Call Site (generated UI action, passing arguments in PK order)</b>
   *
   * <pre>{@code
   * const user = (await ApiHandler.handle<UserModel>(
   *   fetch,
   *   (api) =>
   *     api.user.get(
   *       params.userId,     // PK1
   *       params.accountId   // PK2
   *     )
   * ))!;
   * }</pre>
   *
   * @param entry a map entry where the key is the API path string, and the value is the
   *     corresponding {@link PathItem}. A {@code PathItem} represents an API path item that
   *     contains multiple HTTP operations (such as GET, POST, PUT, DELETE), each of which can
   *     declare its own parameters as well as path-level parameters. This method may update the
   *     ordering of parameters within the {@code PathItem} to match the placeholder order in the
   *     API path template
   */
  private void reorderPathParameters(Map.Entry<String, PathItem> entry) {
    List<String> pathParamNames = extractPathParamNames(entry.getKey());
    if (pathParamNames.size() < 2) {
      return;
    }

    entry
        .getValue()
        .getOperations()
        .values()
        .forEach(
            op -> {
              List<Parameter> reordered = orderByPathParamNames(op.getParameters(), pathParamNames);
              op.setParameters(reordered);
            });
  }

  private List<String> extractPathParamNames(String path) {
    return PATH_VAR.matcher(path).results().map(match -> match.group(1)).toList();
  }

  private List<Parameter> orderByPathParamNames(
      List<Parameter> params, List<String> pathParamNames) {
    Map<String, Integer> indexMap = new HashMap<>();
    for (int i = 0; i < pathParamNames.size(); i++) {
      indexMap.put(pathParamNames.get(i), i);
    }

    return params.stream()
        .sorted(
            Comparator.comparingInt(param -> indexMap.getOrDefault(param.getName(), params.size())))
        .toList();
  }
}
