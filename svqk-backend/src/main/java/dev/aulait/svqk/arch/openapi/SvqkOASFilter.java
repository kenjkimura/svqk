package dev.aulait.svqk.arch.openapi;

import io.quarkus.runtime.annotations.RegisterForReflection;
import io.quarkus.smallrye.openapi.OpenApiFilter;
import java.util.*;
import java.util.regex.Pattern;
import org.eclipse.microprofile.openapi.OASFilter;
import org.eclipse.microprofile.openapi.models.OpenAPI;
import org.eclipse.microprofile.openapi.models.PathItem;
import org.eclipse.microprofile.openapi.models.parameters.Parameter;

@OpenApiFilter
@RegisterForReflection
public class SvqkOASFilter implements OASFilter {
  private static final Pattern PATH_VAR = Pattern.compile("\\{([^}/]+)\\}");

  @Override
  public void filterOpenAPI(OpenAPI openAPI) {
    if (openAPI == null || openAPI.getPaths() == null) return;

    openAPI.getPaths().getPathItems().entrySet().stream().forEach(this::reorderPathParameters);
  }

  /**
   * Reorders path parameters in OpenAPI instance to match path parameters on api path. The other
   * parameters such as query parameters retain their original order and are placed after the path
   * parameters.
   *
   * <p>This process is required to ensure the correctness of files automatically generated by
   * svqk-generator. svqk-generator generates API clients from OpenAPI documents produced by
   * Quarkus. However, Quarkus outputs path parameters in alphanumeric order by default. As a
   * result, the mapping between function arguments in the generated client and the actual path
   * parameters may become inconsistent, causing users to pass unintended values.
   *
   * <p><b>Problematic Example</b>:
   *
   * <pre>{@code
   * Path:
   *   GET /api/to/{paramX}/{paramY}/{paramA}/{paramB}/
   *
   * Generated Api Client Function:
   *   get: (
   *     paramA: string,
   *     paramB: string,
   *     paramX: string,
   *     paramY: string,
   *     ...
   *   ) => this.request<SampleModel, any>({
   *     path: `/api/to/${paramX}/${paramY}/${paramA}/${paramB}`,
   *     method: "GET",
   *     format: "json",
   *     ...params,
   *   })
   * }</pre>
   */
  private void reorderPathParameters(Map.Entry<String, PathItem> entry) {
    List<String> pathParamNames = extractPathParamNames(entry.getKey());
    if (pathParamNames.size() < 2) {
      return;
    }

    entry
        .getValue()
        .getOperations()
        .values()
        .forEach(
            op -> {
              List<Parameter> reordered = orderByPathParamNames(op.getParameters(), pathParamNames);
              op.setParameters(reordered);
            });
  }

  private List<String> extractPathParamNames(String path) {
    return PATH_VAR.matcher(path).results().map(match -> match.group(1)).toList();
  }

  private List<Parameter> orderByPathParamNames(
      List<Parameter> params, List<String> pathParamNames) {
    Map<String, Integer> indexMap = new HashMap<>();
    for (int i = 0; i < pathParamNames.size(); i++) {
      indexMap.put(pathParamNames.get(i), i);
    }

    return params.stream()
        .sorted(
            Comparator.comparingInt(param -> indexMap.getOrDefault(param.getName(), params.size())))
        .toList();
  }
}
