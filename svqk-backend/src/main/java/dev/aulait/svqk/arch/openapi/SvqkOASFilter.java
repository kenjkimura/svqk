package dev.aulait.svqk.arch.openapi;

import io.quarkus.runtime.annotations.RegisterForReflection;
import io.quarkus.smallrye.openapi.OpenApiFilter;
import java.rmi.server.Operation;
import java.util.*;
import java.util.regex.Pattern;
import org.eclipse.microprofile.openapi.OASFilter;
import org.eclipse.microprofile.openapi.models.OpenAPI;
import org.eclipse.microprofile.openapi.models.PathItem;
import org.eclipse.microprofile.openapi.models.parameters.Parameter;

@OpenApiFilter
@RegisterForReflection
public class SvqkOASFilter implements OASFilter {
  private static final Pattern PATH_VAR = Pattern.compile("\\{([^}/]+)\\}");

  @Override
  public void filterOpenAPI(OpenAPI openAPI) {
    if (openAPI == null || openAPI.getPaths() == null) return;

    openAPI.getPaths().getPathItems().entrySet().stream().forEach(this::reorderPathParameters);
  }

  /**
   * Reorders the path parameters within an OpenAPI instance to match the order of placeholders as
   * defined in the API path. Non-path parameters such as query or header parameters retain their
   * original relative order and are placed after the path parameters.
   *
   * <p>In OpenAPI documents generated by {@code svqk-generator}, path parameters are arranged
   * alphabetically by name (a). The same tool then generates API client code from those documents
   * (b). However, when this generated API client is used by the code generated for single-record
   * GET, UPDATE, or DELETE operations (also produced by {@code svqk-generator}), the arguments are
   * passed in the order of the target table’s primary keys — which corresponds to the placeholder
   * order in the API path (c).
   *
   * <p>Consequently, if the parameter order in the OpenAPI document does not match the argument
   * order at runtime, incorrect values may be passed to the API.
   *
   * <p><b>References:</b>
   *
   * <ul>
   *   <li>(a) {@code svqk-generator} generates OpenAPI documents using Quarkus.<br>
   *       See {@code svqk-generator/.yo-rc.json} (property: {@code genOpenApiJsonCmd}).
   *   <li>(b) {@code svqk-generator} uses {@code swagger-typescript-api} to generate the API
   *       client.<br>
   *       See {@code svqk-generator/src/main/lib/ApiClientGenerator.ts}.
   *   <li>(c) The code generation for single-record operations is implemented in the following
   *       templates and shared functions, and occurs when {@code templateType} in {@code
   *       yo-rc.json} is changed from {@code "skeleton"} (default) to {@code "arch"}:<br>
   *       {@code generators/app/templates/arch/frontend/routes/entityId/+page.ts}<br>
   *       {@code generators/app/templates/lib/typescript-common.ejs} (function: {@code
   *       buildDetailApiCall})
   * </ul>
   *
   * <p><b>Problematic Example:</b>
   *
   * <pre>{@code
   * Function definition: parameters are sorted alphabetically
   * get: (
   *   accountId: string,
   *   userId: string,
   *   params: RequestParams = {}
   * ) =>
   *   this.request<UserModel, any>({
   *     path: `/api/user/${userId}/${accountId}`,
   *     method: "GET",
   *     format: "json",
   *     ...params,
   *   }),
   *
   * Caller passes arguments in primary key order, not alphabetical
   * const user = (await ApiHandler.handle<UserModel>(
   *   fetch,
   *   (api) =>
   *     api.user.get(
   *       params.userId,
   *       params.accountId
   *     )
   * ))!;
   * }</pre>
   *
   * @param entry a map entry whose key is the API path and whose value is the corresponding {@link
   *     PathItem}. Each {@code PathItem} represents the set of HTTP {@link Operation}s for that
   *     path, each of which already contains its {@code parameters} and can be accessed from the
   *     OASFilter.
   */
  private void reorderPathParameters(Map.Entry<String, PathItem> entry) {
    List<String> pathParamNames = extractPathParamNames(entry.getKey());
    if (pathParamNames.size() < 2) {
      return;
    }

    entry
        .getValue()
        .getOperations()
        .values()
        .forEach(
            op -> {
              List<Parameter> reordered = orderByPathParamNames(op.getParameters(), pathParamNames);
              op.setParameters(reordered);
            });
  }

  private List<String> extractPathParamNames(String path) {
    return PATH_VAR.matcher(path).results().map(match -> match.group(1)).toList();
  }

  private List<Parameter> orderByPathParamNames(
      List<Parameter> params, List<String> pathParamNames) {
    Map<String, Integer> indexMap = new HashMap<>();
    for (int i = 0; i < pathParamNames.size(); i++) {
      indexMap.put(pathParamNames.get(i), i);
    }

    return params.stream()
        .sorted(
            Comparator.comparingInt(param -> indexMap.getOrDefault(param.getName(), params.size())))
        .toList();
  }
}
