package dev.aulait.svqk.arch.openapi;

import io.quarkus.runtime.annotations.RegisterForReflection;
import io.quarkus.smallrye.openapi.OpenApiFilter;
import java.util.*;
import java.util.regex.Pattern;
import org.eclipse.microprofile.openapi.OASFilter;
import org.eclipse.microprofile.openapi.models.OpenAPI;
import org.eclipse.microprofile.openapi.models.PathItem;
import org.eclipse.microprofile.openapi.models.parameters.Parameter;

@OpenApiFilter
@RegisterForReflection
public class SvqkOASFilter implements OASFilter {
  private static final Pattern PATH_VAR = Pattern.compile("\\{([^}/]+)\\}");

  @Override
  public void filterOpenAPI(OpenAPI openAPI) {
    if (openAPI == null || openAPI.getPaths() == null) return;

    openAPI.getPaths().getPathItems().entrySet().stream().forEach(this::reorderPathParameters);
  }

  /**
   * Reorders path parameters in the OpenAPI instance to match the placeholder order in the API
   * path. The other parameters such as query parameters retain their original order and are placed
   * after the path parameters.
   *
   * <p>The OpenAPI documents generated by svqk-generator list path parameters in alphabetical order
   * of their names (a). From these OpenAPI documents, svqk-generator generates API clients (b).
   * However, at the call sites where the generated API clients are used for single-record
   * GET/UPDATE/DELETE operations, path parameters are expected in the primary-key order of the
   * target table, which corresponds to the placeholder order in the API path (c).
   *
   * <p>This filter is invoked during OpenAPI document generation and normalizes the order of path
   * parameters from alphabetical order to the placeholder order.
   *
   * <p>References:
   *
   * <p>(a) svqk-generator uses Quarkus to generate OpenAPI documents. See
   * svqk-generator/.yo-rc.json (genOpenApiJsonCmd).
   *
   * <p>(b) svqk-generator uses swagger-typescript-api to generate API clients. See
   * svqk-generator/src/main/lib/ApiClientGenerator.ts.
   *
   * <p>(c) This generation logic is implemented in the following templates and shared functions:
   * generators/app/templates/arch/frontend/routes/entityId/+page.ts
   * generators/app/templates/lib/typescript-common.ejs (buildDetailApiCall)
   *
   * <p><b>Problematic Example</b>:
   *
   * <pre>{@code
   * Path:
   *   GET /api/user/{userId}/{accountId}
   *
   * Generated Api Client Function (alphabetical order):
   *   get: (accountId: string, userId: string)
   *
   * Call site:
   *   api.user.get(userId, accountId)
   *
   * Expected request:
   *   GET /api/user/10/A
   *
   * Actual request:
   *   GET /api/user/A/10
   * }</pre>
   *
   * @param entry a map entry where the key is the API path string and the value is the {@link
   *     PathItem} associated with that path; this method may update the ordering of parameters
   *     within the {@code PathItem}.
   */
  private void reorderPathParameters(Map.Entry<String, PathItem> entry) {
    List<String> pathParamNames = extractPathParamNames(entry.getKey());
    if (pathParamNames.size() < 2) {
      return;
    }

    entry
        .getValue()
        .getOperations()
        .values()
        .forEach(
            op -> {
              List<Parameter> reordered = orderByPathParamNames(op.getParameters(), pathParamNames);
              op.setParameters(reordered);
            });
  }

  private List<String> extractPathParamNames(String path) {
    return PATH_VAR.matcher(path).results().map(match -> match.group(1)).toList();
  }

  private List<Parameter> orderByPathParamNames(
      List<Parameter> params, List<String> pathParamNames) {
    Map<String, Integer> indexMap = new HashMap<>();
    for (int i = 0; i < pathParamNames.size(); i++) {
      indexMap.put(pathParamNames.get(i), i);
    }

    return params.stream()
        .sorted(
            Comparator.comparingInt(param -> indexMap.getOrDefault(param.getName(), params.size())))
        .toList();
  }
}
